<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI 146: Mappings</title>
    <link rel="stylesheet" href="http://srfi.schemers.org/srfi.css" type="text/css" />
  </head>

  <body>

<h1>Title</h1>

Mappings

<h1>Author</h1>

Marc Nieper-Wi&szlig;kirchen

<h1>Status</h1>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="http://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+146+at+srfi+dotschemers+dot+org">srfi-146@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="http://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="http://srfi-email.schemers.org/srfi-146">archive</a>.</p>
<ul>
  <li>Received: 2016/12/18</li>
  <li>60-day deadline: 2016/2/16</li>
  <li>Draft #1 published: 2016/12/18</li>
  <li>Draft #2 published: 2016/12/20</li>
</ul>

<h1>Abstract</h1>

<p>
<em>Mappings</em> are finite sets of associations, where each association
is a pair consisting of a key and an arbitrary Scheme value.  The keys
are elements of a suitable domain.  Each mapping holds no more than one
association with the same key.  The fundamental mapping operation is
retrieving the value of an association stored in the mapping when the key
is given.
</p>

<h1>Issues</h1>

There are currently no known issues.

<h1>Rationale</h1>

<p>
Like sets and bags, mappings represent a fundamental data type.
Currently, a Scheme programmer has quite a few means to implement this
data type: The base library has some support for association lists,
which are light-weight data structures that can function as mappings.
More efficient data structures are supported by SRFI 125, namely hash
tables.  Finally, the set data structure of SRFI 113 using suitable
comparators can be used to model mappings.  However, all three means have
individual short-comings when it comes to mappings:
</p>

<p>
Most operations on association lists are of
running time O(n) and thus not very efficient, and association lists
do not implement the restriction that keys have to be unique in mappings.
</p>

<p>
While the hash table model of SRFI 125 implements proper mappings, it
makes very strict assumptions on how these mappings have to implemented.
In particular, these requirements make purely functional mappings based on
SRFI 125 rather inefficient.
</p>

<p>
On the other hand, SRFI 113 has an interface that allows
implementations to implement purely functional mappings efficiently, while
allowing even more efficient mutable data structures when immutability
is not needed.  However, although one can use SRFI 113 to implement
sets of associations, SRFI 113 does not export any procedures that
explicitly deal with sets of associations.
</p>

<p>One can view the interface proposed in this SRFI as the mapping
  analogue of the set interface of SRFI 113.  The choices of names in this SRFI
  are drawn from SRFI 113, SRFI 125, and general Scheme conventions.
</p>

<p>
  Multi-mappings (<i>i.e.</i> general relations) are not covered by this SRFI.
  They are left to a future SRFI should they prove to be essential.
</p>

<h1>Specification</h1>

<p>
Mappings are disjoint from other types of Scheme objects.
</p>

<p>
  It is an error for any procedure defined in this SRFI to be invoked
  on mappings with distinct comparators (in the sense
  of <code>eq?</code>).
</p>

<p>
  It is an error to mutate any key while it is contained in an association in a mapping.
</p>

<p>
  It is an error to add any association to a mapping whose key does not
  satisfy the type test predicate of the comparator.
</p>

<p>
  It is an error to apply any procedures defined in this SRFI whose
  names end in <code>!</code> to a mapping while iterating over it.
</p>

<p>
  When part of an R7RS implementation, the library <code>(srfi
    146)</code> should export exactly those identifiers that are
    described in this specification with the appropriate bindings.  Should
    this SRFI become an essential part of a future Scheme system based
    on R7RS (<i>e.g.</i> R7RS-large), the library's name would
    become <code>(scheme mapping)</code>.
</p>

<h2>Linear update</h2>

<p>The procedures of this SRFI like those of SRFI 113, by default, are
"pure functional" &mdash; they do not alter their parameters.
However, this SRFI also defines "linear-update" procedures, all of
whose names end in <code>!</code>.  They have hybrid
pure-functional/side-effecting semantics: they are allowed, but not
required, to side-effect one of their parameters in order to construct
their result.  An implementation may legally implement these procedures
as pure, side-effect-free functions, or it may implement them using
side effects, depending upon the details of what is the most efficient
  or simple to implement in terms of the underlying representation.
</p>

<p>It is an error to rely upon these procedures working by side
  effect.  For example, this is not guaranteed to work:</p>

<pre>
  (let* ((mapping1
         (mapping (make-default-comparator) 'a 1 'b 2 'c 3)) ; mapping1 = {a&map;1,b&map;2,c&map;3}.
    (mapping2 (mapping-set! mapping1 'd 4))) ; mapping2 = {a&map;1,b&map;2,c&map;3,d&map;4}
  mapping1) ; mapping1 = {a&map;1,b&map;2,c&map;3} or mapping1 = {a&map;1,b&map;2,c&map;3;d&map;4}
</pre>


<p>However, this is well-defined:</p>

<pre>
  (let ((mapping1 (set (make-default-comparator 'a 1 'b 2 'c 3)))
    (mapping-set! mapping1 'd 4)) ; &rArr; {a&map;1,b&map;2,c&map;3;d&map;4}
</pre>

<p>So clients of these procedures write in a functional style, but
must additionally be sure that, when the procedure is called, there
are no other live pointers to the potentially-modified mapping (hence the
term "linear update").</p>

<p>There are two benefits to this convention:</p>

<ul><li><p>Implementations are free to provide the most efficient
possible implementation, either functional or side-effecting.</p></li>

<li><p>Programmers may nonetheless continue to assume that mappings are
purely functional data structures: they may be reliably shared without
needing to be copied, uniquified, and so forth (as long as the mapping in
question is not an argument of a "linear-update"
procedure).</p></li></ul>

<p>In practice, these procedures are most useful for efficiently
constructing mappings in a side-effecting manner, in some limited local
context, before passing the mapping outside the local
construction scope to be used in a functional manner.</p>

<p>Scheme provides no assistance in checking the linearity of the
potentially side-effected parameters passed to these functions &mdash;
there's no linear type checker or run-time mechanism for detecting
violations.</p>

<p>Note that if an implementation uses no side effects at all, it is
allowed to return existing mappings rather than newly allocated ones, even
where this SRFI explicitly says otherwise.  For
example, <code>mapping-copy</code> could be a no-op.</p>

<h2>Comparator restrictions</h2>

<p>Implementations of this SRFI are allowed to place restrictions on
the comparators that the procedures accept as follows:  An
implementation may require comparators to provide a comparison
procedure.  Alternatively, an implementation may require comparators
to provide a hash function, unless the equality predicate of the
comparator
is <code>eq?</code>, <code>eqv?</code>, <code>equal?</code>, <code>string=?</code>,
  or <code>string-ci=?</code>.
</p>

<p>
  In order to allow portable Scheme code to distinguish whether a
  specific implementation of this SRFI supports comparators with
  ordering procedures (in which case sets of keys have a natural
  total order) or comparators with hash functions (or both), it is
  required that an implementation supporting comparators with
  comparison functions not only implements the interface in
  the <code>(srfi 146)</code> namespace, but also in the <code>(srfi
  146 ordered)</code> namespace.  Likewise, an implementation
  supporting comparators with hash functions implements the interface
  in the <code>(srfi 146)</code> namespace also in the <code>(srfi 146
  hash)</code> namespace.  Procedures that are exported from the
  the <code>(srfi 146 ordered)</code> namespace have additional
  restrictions (see below).  What has been said above should be true
  for all alternatives to <code>(srfi 146)</code>,
  <i>e.g.</i> <code>(scheme mapping)</code>.
</p>

<p>
  Portable Scheme code can distinguish implementations of this SRFI using <code>cond-expand</code>:
</p>

<pre>
  (cond-expand
    ((library (srfi 146 hash))
     ...) ; code that sets up comparators with hash functions
    ((library (srfi 146 ordered))
     ...)) ; code that sets up comparators with ordering procedures
</pre>

<p>
  (Scheme code which would be more performant/more natural with
  ordering procedures instead of hash functions, would change the
  order of the two <code>&lt;cond-expand&gt;</code>-clauses.)
</p>

<p>It is left to a future SRFI that will update SRFI 113 to provide an
  analogous addition to <code>(scheme set)</code>, <em>i.e.</em> to
  specify <code>(scheme set hash)</code> and <code>(scheme set ordered)</code>.
</p>

<h2 id="index">Index</h2>

<ul>
  <li><p><a href="#Constructors">Constructors</a>:
      <code>mapping</code>, <code>mapping-unfold</code></p>
  </li>

  <li><p><a href="#Predicates">Predicates</a>:
      <code>mapping?</code>, <code>mapping-contains?</code>, <code>mapping-empty?</code>,
      <code>mapping-disjoint?</code></p>
  </li>

  <li><p><a href="#Accessors">Accessors</a>:
      <code>mapping-ref</code>, <code>mapping-ref/default</code>,
      <code>mapping-key-comparator</code>
    </p>
  </li>

  <li><p><a href="#Updaters">Updaters</a>:
      <code>mapping-set</code>, <code>mapping-set!</code>,
      <code>mapping-replace</code>, <code>mapping-replace!</code>,
      <code>mapping-delete</code>, <code>mapping-delete!</code>,
      <code>mapping-delete-all</code>, <code>mapping-delete-all!</code>,
      <code>mapping-intern</code>, <code>mapping-intern!</code>,
      <code>mapping-update</code>, <code>mapping-update!</code>,
      <code>mapping-update/default</code>, <code>mapping-update!/default</code>,
      <code>mapping-search</code>, <code>mapping-search!</code></p>
  </li>

  <li><p><a href="#Thewholemapping">The whole mapping</a>:
      <code>mapping-size</code>,
      <code>mapping-find</code>,
      <code>mapping-count</code>,
      <code>mapping-any?</code>,
      <code>mapping-every?</code>,
      <code>mapping-keys</code>,
      <code>mapping-values</code>,
      <code>mapping-entries</code>
    </p>
  </li>
  
  <li><p><a href="#Mappingandfolding">Mapping and folding</a>:
      <code>mapping-map</code>,
      <code>mapping-map-&gt;list</code>,
      <code>mapping-for-each</code>,
      <code>mapping-fold</code>,
      <code>mapping-filter</code>, <code>mapping-filter!</code>,
      <code>mapping-remove</code>,
      <code>mapping-remove!</code>,
      <code>mapping-partition</code>, <code>mapping-partition!</code></p>
  </li>
  
  <li><p><a href="#Copyingandconversion">Copying and conversion</a>:
      <code>mapping-copy</code>,
      <code>mapping-&gt;alist</code>,
      <code>alist-&gt;mapping</code>, <code>alist-&gt;mapping!</code></p>
  </li>

  <li><p><a href="#Submappings">Submappings</a>:
      <code>mapping=?</code>,
      <code>mapping&lt;?</code>,
      <code>mapping&gt;?</code>,
      <code>mapping&lt;=?</code>,
      <code>mapping&gt;=?</code></p>
  </li>

  <li><p><a href="#Settheoryoperations">Set theory operations</a>:
      <code>mapping-union</code>,
      <code>mapping-intersection</code>,
      <code>mapping-difference</code>,
      <code>mapping-xor</code>,
      <code>mapping-union!</code>,
      <code>mapping-intersection!</code>,
      <code>mapping-difference!</code>,
      <code>mapping-xor!</code>
    </p>
  </li>

  <li>
    <p><a href="#Comparators">Comparators</a>:
      <code>mapping-comparator</code>
  </li>
</ul>

<h2 id="Constructors">Constructors</h2>

<p><code>(mapping <em>comparator</em> <em>arg</em> ...)</code></p>

<p>Returns a newly allocated mapping.  The <em>comparator</em> argument is
a <a href="http://srfi.schemers.org/srfi-128/srfi-128.html">SRFI
128</a> comparator, which is used to control and distinguish the keys
of the mapping.  The <code><em>arg</em></code>s alter between keys and values and are
used to initialize the mapping.  In particular, the number
of <code><em>arg</em></code>s has to be even.  Earlier associations
with equal keys take precedence over later arguments.</p>

<p><code>(mapping-unfold <em>stop?</em> <em>mapper</em> <em>successor</em> <em>seed</em> <em>comparator</em>)</code></p>

<p>Create a newly allocated mapping as if by <code>mapping</code>
  using <em>comparator</em>.  If the result of applying the
  predicate <em>stop?</em> to <em>seed</em> is true, return the mapping.
  Otherwise, apply the procedure <em>mapper</em> to <em>seed</em>.
  <em>Mapper</em> returns two values which are added to the mapping as the
  key and the value, respectively.  Then get a new seed by applying the
  procedure <em>successor</em> to <em>seed</em>, and repeat this
  algorithm.  Associations earlier in the list take precedence over those that come later.
</p>

<h2 id="Predicates">Predicates</h2>

<p><code>(mapping? </code><em>obj</em><code>)</code></p>

<p>Returns <code>#t</code> if <code><em>obj</em></code> is a mapping,
and <code>#f</code> otherwise.</p>

<p><code>(mapping-contains? <em>mapping</em> <em>key</em>)</code></p>

<p>Returns <code>#t</code> if <code><em>key</em></code> is the key of an
association of <code><em>mapping</em></code> and <code>#f</code> otherwise.</p>

<p><code>(mapping-empty? <em>mapping</em>)</code></p>

<p>Returns <code>#t</code> if <em>mapping</em> has no associations and <code>#f</code> otherwise.</p>

<p><code>(mapping-disjoint? <em>mapping<sub>1</sub></em> <em>mapping<sub>2</sub></em>)</code></p>

<p>Returns <code>#t</code> if <code><em>mapping<sub>1</sub></em></code>
and <code><em>mapping<sub>2</sub></em></code> have no keys in common
and <code>#f</code> otherwise.</p>

<h2 id="Accessors">Accessors</h2>

The following three procedures, given a key, return the corresponding value.

<p><code>(mapping-ref <em>mapping</em> <em>key</em> <em>failure</em> <em>success</em>)</code></p>
<p><code>(mapping-ref <em>mapping</em> <em>key</em> <em>failure</em>)</code></p>
<p><code>(mapping-ref <em>mapping</em> <em>key</em>)</code></p>

<p>Extracts the value associated to <code><em>key</em></code>
  in the mapping <code><em>mapping</em></code>, invokes the
  procedure <code><em>success</em></code> on it, and returns its result;
  if <code><em>success</em></code> is not provided, then the value
  itself is return.  If <code><em>key</em></code> is not contained
  in <code><em>mapping</em></code> and <code><em>failure</em></code> is
  supplied, then <code><em>failure</em></code> is invoked on no
  arguments and its result is return.  Otherwise, it is an error.
</p>

<p><code>(mapping-ref/default <em>mapping</em> <em>key</em> <em>default</em>)</code></p>

Semantically equivalent to, but may be more efficient than, the following code:

<pre>
  (mapping-ref <em>mapping</em> <em>key</em> (lambda () <em>default</em>))
</pre>

<p><code>(mapping-key-comparator <em>mapping</em>)</code></p>

<p>Returns the comparator used to compare the keys of the mapping <em>mapping</em>.</p>

<h2 id="Updaters">Updaters</h2>

<p><code>(mapping-set <em>mapping</em> <em>arg</em> ...)</code></p>

<p>The <code>mapping-set</code> procedure returns a newly allocated mapping
  that uses the same comparator as the mapping <code><em>mapping</em></code> and
  contains all the associations of <code><em>mapping</em></code>, and in
  addition new associations by processing the arguments from left to
  right. The <code><em>arg</em></code>s alternate between keys and
  values.  Whenever there is a previous association for a key, it is
  deleted.  It is an error to add an element
  to <code><em>mapping</em></code> that does not return <code>#t</code>
  when passed to the type test procedure of the comparator.
</p>

<p><code>(mapping-set! <em>mapping</em> <em>arg</em> ...)</code></p>

<p>The <code>mapping-set!</code> procedure is the same
  as <code>mapping-set</code>, except that it is permitted to mutate and
  return the <code><em>mapping</em></code> argument rather than allocating
  a new mapping.
</p>

<p><code>(mapping-replace <em>mapping</em> <em>key</em> <em>value</em>)</code></p>

<p>
  The <code>mapping-replace</code> procedure returns a newly allocated mapping
  that uses the same comparator as the mapping <em>mapping</em> and contains all the
  associations of <em>mapping</em> except as follows: If <code><em>key</em></code> is equal
  (in the sense of <code><em>mapping</em></code>'s comparator) to an existing key
  of <code><em>set</em></code>, then the association for that key is omitted and replaced
  the association defined by the pair <code><em>key</em></code> and <code><em>value</em></code>.
  If there is no such key in <code><em>mapping</em></code>,
  then <code><em>mapping</em></code> is returned unchanged.
</p>

<p><code>(mapping-replace! <em>mapping</em> <em>key</em> <em>value</em>)</code></p>

<p>The <code>mapping-replace!</code> procedure is the same
as <code>mapping-replace</code>, except that it is permitted to mutate and
return the <code><em>mapping</em></code> argument rather than allocating a new
  mapping.
</p>

<p><code>(mapping-delete <em>mapping</em> <em>key</em> ...)</code></p>

<p><code>(mapping-delete! <em>mapping</em> <em>key</em> ...)</code></p>

<p><code>(mapping-delete-all <em>mapping</em> <em>key-list</em>)</code></p>

<p><code>(mapping-delete-all! <em>mapping</em> <em>key-list</em>)</code></p>

<p>The <code>mapping-delete</code> procedure returns a newly allocated mapping
containing all the associations of the mapping <code><em>mapping</em></code>
except for any whose keys are equal (in the sense
of <code><em>mapping</em></code>'s comparator) to one or more of
the <code><em>key</em></code>s.  Any <code><em>key</em></code> that is
not equal to some key of the mapping is ignored.</p>

<p>The <code>mapping-delete!</code> procedure is the same
as <code>mapping-delete</code>, except that it is permitted to mutate and
return the <code><em>mapping</em></code> argument rather than allocating a
new mapping.</p>

<p>The <code>mapping-delete-all</code> and <code>mapping-delete-all!</code>
procedures are the same as <code>mapping-delete</code>
and <code>mapping-delete!</code>, respectively, except that they accept a
single argument which is a list of keys whose associations are to be
  deleted.
</p>

<p><code>(mapping-intern <em>mapping</em> <em>key</em> <em>failure</em>)</code></p>

<p>Extracts the value associated to <code><em>key</em></code> in the
  mapping <code><em>mapping</em></code>, and returns <code><em>mapping</em></code>
  and the value as two values.  If <code><em>key</em></code> is not
  contained
  in <code><em>mapping</em></code>, <code><em>failure</em></code> is
  invoked on no arguments.  The procedure then returns two values, a
  newly allocated mapping that uses the same comparator as
  the <code><em>mapping</em></code> and contains all the associations
  of <code><em>mapping</em></code>, and in addition a new association
  mapping
  <em>key</em> to the result of invoking <code><em>failure</em></code>,
  and the result of invoking <code><em>failure</em></code>.
</p>

<p><code>(mapping-intern! <em>mapping</em> <em>key</em> <em>failure</em>)</code></p>

<p>The <code>mapping-intern!</code> procedure is the same
as <code>mapping-intern</code>, except that it is permitted to mutate and
return the <code><em>mapping</em></code> argument as its first value
rather than allocating a new mapping.
</p>

<p><code>(mapping-update <em>mapping</em> <em>key</em> <em>updater</em> <em>failure</em> <em>success</em>)</code></p>

<p><code>(mapping-update <em>mapping</em> <em>key</em> <em>updater</em> <em>failure</em>)</code></p>

<p><code>(mapping-update <em>mapping</em> <em>key</em> <em>updater</em>)</code></p>

Semantically equivalent to, but may be more efficient than, the following code
<pre>
  (mapping-set <em>mapping</em> <em>key</em> (<em>updater</em> (mapping-ref <em>mapping</em> <em>key</em> <em>failure</em> <em>success</em>)))
</pre>

<p>
  The obvious semantics hold when <code><em>success</em></code> (and <code><em>failure</em></code>)
  are omitted (see <code>mapping-ref</code>).
</p>

<p><code>(mapping-update! <em>mapping</em> <em>key</em> <em>updater</em> <em>failure</em> <em>success</em>)</code></p>

<p><code>(mapping-update! <em>mapping</em> <em>key</em> <em>updater</em> <em>failure</em>)</code></p>

<p><code>(mapping-update! <em>mapping</em> <em>key</em> <em>updater</em>)</code></p>

<p>The <code>mapping-update!</code> procedure is the same
  as <code>mapping-update</code>, except that it is permitted to mutate and
  return the <code><em>mapping</em></code> argument rather than allocating
  a new mapping.
</p>

<p><code>(mapping-update/default <em>mapping</em> <em>key</em> <em>updater</em> <em>default</em>)</code></p>

Semantically equivalent to, but may be more efficient than, the following code
<pre>
  (mapping-set <em>mapping</em> <em>key</em> (<em>updater</em> (mapping-ref/default <em>mapping</em> <em>key</em> <em>default</em>)))
</pre>

<p><code>(mapping-update!/default <em>mapping</em> <em>key</em> <em>updater</em> <em>default</em>)</code></p>

<p>The <code>mapping-update!/default</code> procedure is the same
  as <code>mapping-update/default</code>, except that it is permitted to mutate and
  return the <code><em>mapping</em></code> argument rather than allocating
  a new mapping.
</p>

<p><code>(mapping-search <em>mapping</em> <em>key</em> <em>failure</em> <em>success</em>)</code></p>

<p>The mapping <code><em>mapping</em></code> is searched for an association
with key <code><em>key</em></code>.  If it is not found, then
the <code><em>failure</em></code> procedure is tail-called with two
continuation arguments, <code><em>insert</em></code>
and <code><em>ignore</em></code>, and is expected to tail-call one of
them.  If an association with key <code><em>key</em></code> is found,
then the <code><em>success</em></code> procedure is tail-called with
the matching key of <code><em>mapping</em></code>, the associated value,
and two continuations, <code><em>update</em></code>
and <code><em>remove</em></code>, and is expected to tail-call one of
them.
</p>

<p>If <code>mapping-search</code> is imported from <code>(srfi 146
    ordered)</code>, <code><em>mapping</em></code> is searched in order
    (that is in the order of the stored keys).
</p>

<p>
It is an error if the continuation arguments are invoked, but not in
tail position in the
<code><em>failure</em></code> and <code><em>success</em></code>
procedures.  It is also an error if the <code><em>failure</em></code>
and <code><em>success</em></code> procedures return to their implicit
continuation without invoking one of their continuation arguments.
</p>

<p>The effects of the continuations are as follows
(where <code><em>obj</em></code> is any Scheme object):
</p>

<ul>
<li><p>Invoking <code>(<em>insert</em> <em>value</em> <em>obj</em>)</code>
causes a mapping to be newly allocated that uses the same comparator as
the mapping <code><em>mapping</em></code> and contains all the associations
of <code><em>mapping</em></code>, and in addition a new association
mapping <code><em>key</em></code> to <code><em>value</em></code>.
</p></li>
<li>
  <p>Invoking <code>(<em>ignore</em> <em>obj</em>)</code>
    has no effects; in particular, no new mapping is allocated (but see below).
  </p>
</li>
<li>
  <p>Invoking <code>(<em>update</em> <em>new-key</em> <em>new-value</em>
      <em>obj</em>)</code> causes a mapping to be newly allocated that
    uses the same comparator as the <code><em>mapping</em></code> and
    contains all the associations of <code><em>mapping</em></code>, except
    for the association with key <code><em>key</em></code>, which is
    replaced by a new association
    mapping <code><em>new-key</em></code>
    to <code><em>new-value</em></code>.
  </p>
</li>
<li>
  <p>Invoking <code>(<em>remove</em> <em>obj</em>)</code>
    causes a mapping to be newly allocated that
    uses the same comparator as the <code><em>mapping</em></code> and
    contains all the associations of <code><em>mapping</em></code>, except
    for the association with key <code><em>key</em></code>.
  </p>
</li>
</ul>

<p>In all cases, two values are returned: the possibly newly
allocated <code><em>mapping</em></code> and
  <code><em>obj</em></code>.
</p>

<p><code>(mapping-search! <em>mapping</em> <em>key</em> <em>failure</em> <em>success</em>)</code></p>

<p>The <code>mapping-search!</code> procedure is the same
  as <code>mapping-search</code>, except that it is permitted to mutate
  and return the <code><em>mapping</em></code> argument rather than
  allocating a new mapping.
</p>

<h2 id="Thewholemapping">The whole mapping</h2>

<p><code>(mapping-size <em>mapping</em>)</code></p>

<p>
Returns the number of associations in <em>mapping</em> as an exact integer.
</p>

<p><code>(mapping-find <em>predicate</em> <em>mapping</em> <em>failure</em>)</code></p>

<p>
  Returns an arbitrarily chosen association
  of the mapping <code><em>mapping</em></code> consisting of a key and value as two
  values such that <code><em>predicate</em></code> returns a true
  value when invoked with key and value as arguments, or the result of
  invoking <code><em>failure</em></code> with no arguments if there is
  none.  There are no guarantees how many times and with which keys and values
  <code><em>predicate</em></code> is invoked, but see below:
</p>

<p>If <code>mapping-find</code> is imported from <code>(srfi 146
    ordered)</code>, <code><em>mapping</em></code> is searched in order:
    The association with the least key that
    satisfies <code><em>predicate</em></code> is returned.
</p>

<p><code>(mapping-count <em>predicate</em> <em>mapping</em>)</code></p>

<p>
Returns the number of associations of the mapping <em>mapping</em> that
satisfy <code><em>predicate</em></code> (in the sense
of <code>mapping-find</code>) as an exact integer.

</p><p><code>(mapping-any? <em>predicate</em> <em>mapping</em>)</code></p>

<p>
Returns <code>#t</code> if any association of the mapping <code><em>mapping</em></code>
satisfies <code><em>predicate</em></code> (in the sense
of <code>mapping-find</code>), or <code>#f</code> otherwise.
</p>

<p><code>(mapping-every? <em>predicate</em> <em>mapping</em>)</code></p>

<p>
Returns <code>#t</code> if every association of the
mapping <code><em>mapping</em></code>
satisfies <code><em>predicate</em></code> (in the sense
of <code>mapping-find</code>), or <code>#f</code> otherwise.
</p>

<p><code>(mapping-keys <em>mapping</em>)</code></p>

<p>Returns a newly allocated list of all the keys in the mapping <code><em>mapping</em></code>.</p>

<p>If <code>mapping-keys</code> is imported from <code>(srfi 146
    ordered)</code>, the list is returned in order:  It is ordered
  according to the ordering of the keys.
</p>

<p><code>(mapping-values <em>mapping</em>)</code></p>

<p>
  Returns a newly allocated list of all the values in the mapping <code><em>mapping</em></code>.
</p>

<p>If <code>mapping-values</code> is imported from <code>(srfi 146
    ordered)</code>, the list is returned in order:  It is ordered
  according to the ordering of the keys corresponding to the values.
</p>

<p><code>(mapping-entries <em>mapping</em>)</code></p>

<p>
Returns two values, a newly allocated list of all the keys in the
mapping <code><em>mapping</em></code>, and a newly allocated list of all the
values in the mapping <code><em>mapping</em></code>.  The two lists are
consistently ordered,  so that keys can be matched to their corresponding values.
</p>

<p>If <code>mapping-values</code> is imported from <code>(srfi 146
    ordered)</code>, the lists is returned in order:  They are ordered
  according to the ordering of the keys.
</p>

<h2 id="Mappingandfolding">Mapping and folding</h2>

<p><code>(mapping-map <em>proc</em> <em>comparator</em> <em>mapping</em>)</code></p>

<p>Applies <code><em>proc</em></code> on two arguments, the key and value of each association of 
  <code><em>mapping</em></code> in arbitrary order (but see below), which returns two
  values, and returns a newly allocated mapping that uses the
  comparator <code><em>comparator</em></code>, and which contains
  the results of the applications inserted as keys and values. Note
  that this is more akin to <code>set-mapping</code> from SRFI 113 than
  to <code>hash-table-mapping</code> from SRFI 125. For example:
</p>

<pre>
  (mapping-map (proc (key value)
             (values (symbol-&gt;string key) value))
           (make-default-comparator)
           (mapping (make-default-comparator) 'foo 1 'bar 2 'baz 3))
  ; &rArr; (mapping (make-default-comparator) "foo" 1 "bar" 2 "baz" 3)
</pre>

<p>Note that, when <code><em>proc</em></code> defines a mapping that
is not 1:1 between the keys, some of the mapped objects may be
equivalent in the sense of the <code><em>mapping</em></code>'s
comparator's equality predicate, and in this case duplicate elements
are omitted as in the mapping constructor.  It is unpredictable which one
will be preserved in the result.
</p>

<p>If <code>mapping-map</code> is imported from <code>(srfi 146
    ordered)</code>, the associations are mapped in order:  They are ordered
  according to the natural ordering of the keys.
</p>

<p><code>(mapping-for-each <em>proc</em> <em>mapping</em>)</code></p>

<p>Invokes <code><em>proc</em></code> for every association in the
mapping <code><em>mapping</em></code> in arbitrary order (but see below), discarding the
returned values, with two arguments: the key of the association and
the value of the association.  Returns an unspecified value.
</p>

<p>If <code>mapping-for-each</code> is imported from <code>(srfi 146
    ordered)</code>, the associations are processed in order:  They are ordered
  according to the natural ordering of the keys.
</p>

<p><code>(mapping-fold <em>proc</em> <em>nil</em> <em>mapping</em>)</code></p>

<p>Invokes <code><em>proc</em></code> for each association of the
mapping <code><em>mapping</em></code> in arbitrary order (but see below) with
three arguments: the key of the association, the value of the
association, and an accumulated result of the previous
invocation.  For the first invocation, <code><em>nil</em></code> is
used as the second argument.  Returns the result of the last
invocation, or <code><em>nil</em></code> if there was no invocation.
</p>

<p>If <code>mapping-fold</code> is imported from <code>(srfi 146
    ordered)</code>, the associations are accumulated in order:  They are ordered
  according to the natural ordering of the keys.
</p>

<p><code>(mapping-map-&gt;list <em>proc</em> <em>mapping</em>)</code></p>

<p>
Calls <code><em>proc</em></code> for every association in the
mapping <code><em>mapping</em></code> with two arguments: the key of the
association and the value of the association.  The values returned by
the invocations of <code><em>proc</em></code> are accumulated into a
list, which is returned.
</p>

<p>If <code>mapping-map-&gt;list</code> is imported from <code>(srfi 146
    ordered)</code>, the associations are mapped in order:  They are ordered
  according to the natural ordering of the keys.
</p>

<p><code>(mapping-filter <em>predicate</em> <em>mapping</em>)</code></p>

<p>Returns a newly allocated mapping with the same comparator as the
  mapping <code><em>mapping</em></code>, containing just the associations
  of <code><em>mapping</em></code> that satisfy <em>predicate</em> (in the
  sense of <code>mapping-find</code>).
</p>

<p><code>(mapping-filter! <em>predicate</em> <em>mapping</em>)</code></p>

<p>A linear update procedure that returns a mapping containing just the
associations of <code><em>mapping</em></code> that satisfy <code><em>predicate</em></code>.
</p>

<p><code>(mapping-remove <em>predicate</em> <em>mapping</em>)</code></p>

<p>Returns a newly allocated mapping with the same comparator as the
  mapping <code><em>mapping</em></code>, containing just the elements
  of <code><em>mapping</em></code> that do not satisfy <em>predicate</em> (in the
  sense of <code>mapping-find</code>).
</p>

<p><code>(mapping-remove! <em>predicate</em> <em>mapping</em>)</code></p>

<p>A linear update procedure that returns a mapping containing just the
associations of <code><em>mapping</em></code> that do not
satisfy <code><em>predicate</em></code>.
</p>

<p><code>(mapping-partition <em>predicate</em> <em>mapping</em>)</code></p>

<p>Returns two values: a newly allocated mapping with the same comparator
as the mapping <code><em>mapping</em></code> that contains just the
associations of <code><em>mapping</em></code> that
satisfy <code><em>predicate</em></code> (in the sense
of <code>mapping-find</code>), and another newly allocated mapping, also with
the same comparator, that contains just the associations
of <code><em>mapping</em></code> that do not
satisfy <code><em>predicate</em></code>.</p>

<p><code>(mapping-partition! <em>predicate</em> <em>mapping</em>)</code></p>

<p>A linear update procedure that returns two mappings containing the associations of
  <code><em>mapping</em></code> that do and do not, respectively, satisfy
  <code><em>predicate</em></code>.
</p>

<h2 id="Copyingandconversion">Copying and conversion</h2>

<p><code>(mapping-copy <em>mapping</em>)</code></p>

<p>
Returns a newly allocated mapping containing the elements of the
mapping <code><em>mapping</em></code>, and using the same comparator.
</p>

<p><code>(mapping-&gt;alist <em>mapping</em>)</code></p>

<p>
  Returns a newly allocated association list containing the
  associations of the <code><em>mapping</em></code> in unspecified order (but see below).
  Each association in the list is a pair whose car is the key and
  whose cdr is the associated value.
</p>

<p>If <code>mapping-&gt;alist</code> is imported from <code>(srfi 146
    ordered)</code>, the association list is in order:  It is ordered
  according to the natural ordering of the keys.
</p>

<p><code>(alist-&gt;mapping <em>comparator</em> <em>alist</em>)</code></p>

<p>
Returns a newly allocated mapping, created as if by <code>mapping</code>
using the comparator <code><em>comparator</em></code>, that contains
the associations in the list, which consist of a pair whose car is the
key and whose cdr is the value.  Associations earlier in the list take
precedence over those that come later.
</p>

<p><code>(alist-&gt;mapping! <em>mapping</em> <em>alist</em>)</code></p>

<p>
A linear update procedure that returns a mapping that contains the
associations of both <code><em>mapping</em></code>
and <code><em>alist</em></code>.  Associations in the mapping and those
earlier in the list take precedence over those that come later.
</p>

<h2 id="Submappings">Submappings</h2>

<p>Note: The following three predicates do not obey the trichotomy law
and therefore do not constitute a total order on mappings.
</p>

<p>All predicates in this subsection take
a <code><em>comparator</em></code> argument, which is a comparator
used to compare the values of the associations stored in the mappings.
This comparator is used to define the equality of associations.  Two
associations are equal if and only if their keys and values are equal,
respectively.
</p>

<p><code>(mapping=? <em>comparator</em> <em>mapping<sub>1</sub></em> <em>mapping<sub>2</sub></em> ...)</code></p>

<p>Returns <code>#t</code> if each mapping <code><em>mapping</em></code>
contains the same associations, and <code>#f</code> otherwise.
</p>

<p><code>(mapping&lt;? <em>comparator</em> <em>mapping<sub>1</sub></em> <em>mapping<sub>2</sub></em> ...)</code></p>

<p>Returns <code>#t</code> if the set of associations of each
mapping <code><em>mapping</em></code> other than the last is a proper subset
of the following <em>mapping</em>, and <code>#f</code> otherwise.</p>

<p><code>(mapping&gt;? <em>comparator</em> <em>mapping<sub>1</sub></em> <em>mapping<sub>2</sub></em> ...)</code></p>

<p>Returns <code>#t</code> if the set of associations of each
mapping <code><em>mapping</em></code> other than the last is a proper superset
of the following <em>mapping</em>, and <code>#f</code> otherwise.</p>

<p><code>(mapping&lt;=? <em>comparator</em> <em>mapping<sub>1</sub></em> <em>mapping<sub>2</sub></em> ...)</code></p>

<p>Returns <code>#t</code> if the set of associations of each
mapping <code><em>mapping</em></code> other than the last is a subset
of the following <em>mapping</em>, and <code>#f</code> otherwise.</p>

<p><code>(mapping&gt;=? <em>comparator</em> <em>mapping<sub>1</sub></em> <em>mapping<sub>2</sub></em> ...)</code></p>

<p>Returns <code>#t</code> if the set of associations of each
mapping <code><em>mapping</em></code> other than the last is a superset
of the following <em>mapping</em>, and <code>#f</code> otherwise.</p>

<h2 id="Settheoryoperations">Set theory operations</h2>

<p><code>(mapping-union <em>mapping<sub>1</sub> mapping<sub>2</sub></em> ...)</code></p>

<p><code>(mapping-intersection <em>mapping<sub>1</sub> mapping<sub>2</sub></em> ...)</code></p>

<p><code>(mapping-difference <em>mapping<sub>1</sub> mapping<sub>2</sub></em> ...)</code></p>

<p><code>(mapping-xor <em>mapping<sub>1</sub> mapping<sub>2</sub></em>)</code></p>

<p>
Return a newly allocated mapping whose set of associations is the union,
intersection, asymmetric difference, or symmetric difference of the
sets of associations of the mappings <code><em>mapping</em></code>s.
Asymmetric difference is extended to more than two mappings by taking the
difference between the first mapping and the union of the others.
Symmetric difference is not extended beyond two mappings.  In case of
duplicate keys (in the sense of the equality predicate), associations
in the result mapping are drawn from the first mapping in which they appear.
</p>

<p><code>(mapping-union! <em>mapping<sub>1</sub> mapping<sub>2</sub></em> ...)</code></p>

<p><code>(mapping-intersection! <em>mapping<sub>1</sub> mapping<sub>2</sub></em> ...)</code></p>

<p><code>(mapping-difference! <em>mapping<sub>1</sub> mapping<sub>2</sub></em> ...)</code></p>

<p><code>(mapping-xor! <em>mapping<sub>1</sub> mapping<sub>2</sub></em>)</code></p>

<p>Linear update procedures returning a mapping that is the union,
intersection, asymmetric difference, or symmetric difference of
the <code><em>mapping</em></code>s.  Asymmetric difference is extended to more than two
mappings by taking the difference between the first mapping and the union of
the others.  Symmetric difference is not extended beyond two mappings.
In case of duplicate keys (in the sense of the equality predicate), associations
in the result mapping are drawn from the first mapping in which they appear.
</p>

<h2 id="Comparators">Comparators</h2>

<p><code>(make-mapping-comparator <em>comparator</em>)</code></p>

<p>
  Returns a comparator for mappings that is compatible with the equality
  predicate
  <code>(mapping=? <em>comparator</em> <em>mapping<sub>1</sub></em> <em>mapping<sub>2</sub></em>)</code>.
  These comparators are obliged to provide ordering procedures when
  the implementation of this SRFI requires comparators to provide a
  comparison function, and is obliged to provide hash functions when
  the implementation of this SRFI requires comparators to provide a
  hash function. This allows mappings whose keys are mappings themselves, and
  it allows to compare mappings whose values are mappings.
</p>

<p>If <code>make-mapping-comparator</code> is imported from <code>(srfi
    146 ordered)</code>, the lexicographic ordering with respect to
    the keys (and, in case a tiebreak is neccessary, with respect to
    the ordering of the values) is used.
</p>

The following comparator is used to compare mappings when <code>(make-default-comparator)</code> 
from SRFI 128 is invoked:

<p><code>mapping-comparator</code></p>

<p><code>mapping-comparator</code> is constructed by
invoking <code>make-mapping-comparator</code>
on <code>(make-default-comparator)</code>.
</p>

<h1>Implementation</h1>

<p>
The sample implementation uses a purely functional data structure and
is based on red-black trees.  One could easily implement SRFI 113 on
top of this (or any other) implementation of this SRFI.  The sample
R7RS implementation is based on SRFI 1, SRFI 2, SRFI 8, SRFI 121, SRFI
128, and SRFI 145 for which the sample implementations are included in
the repository.  (Except for SRFI 128, to which the interface proposed
in this SRFI is intimitely tied, the dependencies are trivial.)
</p>

<a href="srfi/146.sld">Source for the reference implementation.</a>

<h1>Acknowledgements</h1>

<p>
Credit goes to John Cowan for SRFI 113 and SRFI 128, to Will Clinger
and John Cowan for SRFI 125, and to Kevin Wortman for his
immutable-maps-proposal.  Special credit also goes to Sudarshan S
Chawathe for his careful reading of the drafts of this SRFI and his
many valuable comments which helped to improve this proposal.
</p>

<p>
Some wording from SRFI 113 and SRFI 125 has been copied <i> mutatis mutandis</i>.
</p>

<h1>Copyright</h1>
Copyright (C) Marc Nieper-Wi&szlig;kirchen (2016).  All Rights Reserved. 

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

<p>
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
